/**
 * Media Model
 * 
 * This model provides database access methods for the establishment_media table.
 * It encapsulates all SQL queries related to establishment photos and returns
 * plain JavaScript objects.
 * 
 * Architecture note: Models are thin data access layers that know about SQL
 * and database structure, but nothing about business rules. Business logic
 * lives in the service layer. This model follows patterns established in
 * reviewModel.js and establishmentModel.js for consistency.
 * 
 * The establishment_media table stores references to images hosted on Cloudinary
 * with three resolution URLs for each image: original, preview, and thumbnail.
 */

import pool from '../config/database.js';
import logger from '../utils/logger.js';

/**
 * Create a new media record in the database
 * 
 * This function inserts a media record with URLs for all three resolutions.
 * The URLs are generated by Cloudinary utilities before being stored here.
 * 
 * @param {Object} mediaData - The media data to insert
 * @param {string} mediaData.establishment_id - UUID of the establishment
 * @param {string} mediaData.type - Media type ('interior', 'exterior', 'menu', 'dishes')
 * @param {string} mediaData.url - Original resolution URL
 * @param {string} mediaData.thumbnail_url - Thumbnail resolution URL (200x150)
 * @param {string} mediaData.preview_url - Preview resolution URL (800x600)
 * @param {string} mediaData.caption - Optional caption/description
 * @param {number} mediaData.position - Display position (default: 0)
 * @param {boolean} mediaData.is_primary - Whether this is the primary photo
 * @returns {Promise<Object>} The created media record with all database fields
 * @throws {Error} If database operation fails
 */
export const createMedia = async (mediaData) => {
  const {
    establishment_id,
    type,
    url,
    thumbnail_url,
    preview_url,
    caption,
    position = 0,
    is_primary = false,
  } = mediaData;

  const query = `
    INSERT INTO establishment_media (
      establishment_id,
      type,
      url,
      thumbnail_url,
      preview_url,
      caption,
      position,
      is_primary
    )
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    RETURNING 
      id,
      establishment_id,
      type,
      url,
      thumbnail_url,
      preview_url,
      caption,
      position,
      is_primary,
      created_at
  `;

  const values = [
    establishment_id,
    type,
    url,
    thumbnail_url,
    preview_url,
    caption || null,
    position,
    is_primary,
  ];

  try {
    const result = await pool.query(query, values);

    logger.info('Media record created', {
      mediaId: result.rows[0].id,
      establishmentId: establishment_id,
      type,
      isPrimary: is_primary,
    });

    return result.rows[0];
  } catch (error) {
    logger.error('Error creating media record', {
      error: error.message,
      establishmentId: establishment_id,
      type,
    });
    throw error;
  }
};

/**
 * Get all media for a specific establishment
 * 
 * Results are ordered by position ASC (for manual ordering) and then by
 * created_at DESC (newest first within same position).
 * 
 * @param {string} establishmentId - UUID of the establishment
 * @param {Object} filters - Optional filters
 * @param {string} filters.type - Optional media type filter
 * @returns {Promise<Array>} Array of media objects
 */
export const getEstablishmentMedia = async (establishmentId, filters = {}) => {
  const { type } = filters;

  const conditions = ['establishment_id = $1'];
  const values = [establishmentId];
  let paramCount = 2;

  if (type) {
    conditions.push(`type = $${paramCount}`);
    values.push(type);
    paramCount++;
  }

  const query = `
    SELECT 
      id,
      establishment_id,
      type,
      url,
      thumbnail_url,
      preview_url,
      caption,
      position,
      is_primary,
      created_at
    FROM establishment_media
    WHERE ${conditions.join(' AND ')}
    ORDER BY position ASC, created_at DESC
  `;

  try {
    const result = await pool.query(query, values);

    logger.debug('Fetched establishment media', {
      establishmentId,
      count: result.rows.length,
      type: type || 'all',
    });

    return result.rows;
  } catch (error) {
    logger.error('Error fetching establishment media', {
      error: error.message,
      establishmentId,
    });
    throw error;
  }
};

/**
 * Find a media record by its ID
 * 
 * @param {string} mediaId - UUID of the media record
 * @returns {Promise<Object|null>} The media object or null if not found
 */
export const findMediaById = async (mediaId) => {
  const query = `
    SELECT 
      id,
      establishment_id,
      type,
      url,
      thumbnail_url,
      preview_url,
      caption,
      position,
      is_primary,
      created_at
    FROM establishment_media
    WHERE id = $1
  `;

  try {
    const result = await pool.query(query, [mediaId]);

    if (result.rows.length === 0) {
      return null;
    }

    return result.rows[0];
  } catch (error) {
    logger.error('Error finding media by ID', {
      error: error.message,
      mediaId,
    });
    throw error;
  }
};

/**
 * Update a media record
 * 
 * This function allows updating caption, position, and is_primary flag.
 * The URLs cannot be updated - to change an image, delete and re-upload.
 * 
 * @param {string} mediaId - UUID of the media to update
 * @param {Object} updates - Fields to update
 * @returns {Promise<Object>} The updated media object
 * @throws {Error} If media not found or database operation fails
 */
export const updateMedia = async (mediaId, updates) => {
  const fields = [];
  const values = [];
  let paramCount = 1;

  // Build dynamic UPDATE query based on provided fields
  if (updates.caption !== undefined) {
    fields.push(`caption = $${paramCount}`);
    values.push(updates.caption);
    paramCount++;
  }

  if (updates.position !== undefined) {
    fields.push(`position = $${paramCount}`);
    values.push(updates.position);
    paramCount++;
  }

  if (updates.is_primary !== undefined) {
    fields.push(`is_primary = $${paramCount}`);
    values.push(updates.is_primary);
    paramCount++;
  }

  if (fields.length === 0) {
    throw new Error('No fields to update');
  }

  // Add mediaId as the last parameter
  values.push(mediaId);

  const query = `
    UPDATE establishment_media
    SET ${fields.join(', ')}
    WHERE id = $${paramCount}
    RETURNING 
      id,
      establishment_id,
      type,
      url,
      thumbnail_url,
      preview_url,
      caption,
      position,
      is_primary,
      created_at
  `;

  try {
    const result = await pool.query(query, values);

    if (result.rows.length === 0) {
      throw new Error('Media not found');
    }

    logger.info('Media updated', {
      mediaId,
      updatedFields: Object.keys(updates),
    });

    return result.rows[0];
  } catch (error) {
    logger.error('Error updating media', {
      error: error.message,
      mediaId,
    });
    throw error;
  }
};

/**
 * Delete a media record from the database
 * 
 * This only removes the database record. The caller is responsible for
 * also deleting the image from Cloudinary to prevent orphaned files.
 * 
 * @param {string} mediaId - UUID of the media to delete
 * @returns {Promise<Object|null>} Deleted media object or null if not found
 */
export const deleteMedia = async (mediaId) => {
  const query = `
    DELETE FROM establishment_media
    WHERE id = $1
    RETURNING 
      id,
      establishment_id,
      type,
      url,
      is_primary
  `;

  try {
    const result = await pool.query(query, [mediaId]);

    if (result.rows.length === 0) {
      return null;
    }

    logger.info('Media deleted', {
      mediaId,
      establishmentId: result.rows[0].establishment_id,
    });

    return result.rows[0];
  } catch (error) {
    logger.error('Error deleting media', {
      error: error.message,
      mediaId,
    });
    throw error;
  }
};

/**
 * Set a media record as primary photo
 * 
 * This function sets is_primary to true for the specified media and
 * false for all other media of the same establishment. This ensures
 * only one primary photo per establishment.
 * 
 * The operation is performed in two queries (not a transaction) because
 * the constraint is soft (not enforced at database level). If atomicity
 * is needed in the future, this can be wrapped in a transaction.
 * 
 * @param {string} establishmentId - UUID of the establishment
 * @param {string} mediaId - UUID of the media to set as primary
 * @returns {Promise<Object>} The updated media object
 */
export const setPrimaryPhoto = async (establishmentId, mediaId) => {
  try {
    // First, set all media for this establishment to is_primary = false
    const clearQuery = `
      UPDATE establishment_media
      SET is_primary = false
      WHERE establishment_id = $1
    `;
    await pool.query(clearQuery, [establishmentId]);

    // Then, set the specified media to is_primary = true
    const setQuery = `
      UPDATE establishment_media
      SET is_primary = true
      WHERE id = $1 AND establishment_id = $2
      RETURNING 
        id,
        establishment_id,
        type,
        url,
        thumbnail_url,
        preview_url,
        caption,
        position,
        is_primary,
        created_at
    `;
    const result = await pool.query(setQuery, [mediaId, establishmentId]);

    if (result.rows.length === 0) {
      throw new Error('Media not found or does not belong to establishment');
    }

    logger.info('Primary photo set', {
      establishmentId,
      mediaId,
    });

    return result.rows[0];
  } catch (error) {
    logger.error('Error setting primary photo', {
      error: error.message,
      establishmentId,
      mediaId,
    });
    throw error;
  }
};

/**
 * Get the next available position for a media type
 * 
 * This function finds the maximum position for a given media type and
 * returns the next position (max + 1). Used when creating new media
 * to automatically append to the end of the list.
 * 
 * @param {string} establishmentId - UUID of the establishment
 * @param {string} type - Media type
 * @returns {Promise<number>} Next available position number
 */
export const getNextPosition = async (establishmentId, type) => {
  const query = `
    SELECT COALESCE(MAX(position), -1) + 1 as next_position
    FROM establishment_media
    WHERE establishment_id = $1 AND type = $2
  `;

  try {
    const result = await pool.query(query, [establishmentId, type]);
    return result.rows[0].next_position;
  } catch (error) {
    logger.error('Error getting next position', {
      error: error.message,
      establishmentId,
      type,
    });
    throw error;
  }
};

/**
 * Count media by type for an establishment
 * 
 * Used to enforce tier-based upload limits. Returns counts grouped by
 * media type (interior, menu, etc.).
 * 
 * @param {string} establishmentId - UUID of the establishment
 * @returns {Promise<Object>} Object with type as key and count as value
 */
export const getMediaCountByType = async (establishmentId) => {
  const query = `
    SELECT 
      type,
      COUNT(*) as count
    FROM establishment_media
    WHERE establishment_id = $1
    GROUP BY type
  `;

  try {
    const result = await pool.query(query, [establishmentId]);

    // Convert array of {type, count} to object {type: count}
    const counts = {};
    result.rows.forEach(row => {
      counts[row.type] = parseInt(row.count, 10);
    });

    logger.debug('Media counts by type', {
      establishmentId,
      counts,
    });

    return counts;
  } catch (error) {
    logger.error('Error counting media by type', {
      error: error.message,
      establishmentId,
    });
    throw error;
  }
};

/**
 * Check if an establishment has a primary photo
 * 
 * Used during submission validation to ensure at least one primary photo
 * is set before allowing moderation submission.
 * 
 * @param {string} establishmentId - UUID of the establishment
 * @returns {Promise<boolean>} True if primary photo exists
 */
export const hasPrimaryPhoto = async (establishmentId) => {
  const query = `
    SELECT EXISTS(
      SELECT 1
      FROM establishment_media
      WHERE establishment_id = $1 AND is_primary = true
    ) as has_primary
  `;

  try {
    const result = await pool.query(query, [establishmentId]);
    return result.rows[0].has_primary;
  } catch (error) {
    logger.error('Error checking primary photo', {
      error: error.message,
      establishmentId,
    });
    throw error;
  }
};

/**
 * Get the primary photo for an establishment
 * 
 * Returns the media record marked as primary, or null if none is set.
 * Used for displaying the establishment's main image in lists and cards.
 * 
 * @param {string} establishmentId - UUID of the establishment
 * @returns {Promise<Object|null>} Primary media object or null
 */
export const getPrimaryPhoto = async (establishmentId) => {
  const query = `
    SELECT 
      id,
      establishment_id,
      type,
      url,
      thumbnail_url,
      preview_url,
      caption,
      position,
      is_primary,
      created_at
    FROM establishment_media
    WHERE establishment_id = $1 AND is_primary = true
    LIMIT 1
  `;

  try {
    const result = await pool.query(query, [establishmentId]);

    if (result.rows.length === 0) {
      return null;
    }

    return result.rows[0];
  } catch (error) {
    logger.error('Error getting primary photo', {
      error: error.message,
      establishmentId,
    });
    throw error;
  }
};

